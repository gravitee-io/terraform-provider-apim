// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"github.com/gravitee-io/terraform-provider-apim/internal/provider/customtypes"
	tfTypes "github.com/gravitee-io/terraform-provider-apim/internal/provider/types"
	"github.com/gravitee-io/terraform-provider-apim/internal/sdk"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"regexp"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &ApplicationDataSource{}
var _ datasource.DataSourceWithConfigure = &ApplicationDataSource{}

func NewApplicationDataSource() datasource.DataSource {
	return &ApplicationDataSource{}
}

// ApplicationDataSource is the data source implementation.
type ApplicationDataSource struct {
	// Provider configured SDK client.
	client *sdk.GraviteeApim

	// environment ID
	EnvironmentID types.String `tfsdk:"environment_id"`

	// organization ID
	OrganizationID types.String `tfsdk:"organization_id"`
}

// ApplicationDataSourceModel describes the data model.
type ApplicationDataSourceModel struct {
	Background     types.String                 `tfsdk:"background"`
	Description    types.String                 `tfsdk:"description"`
	Domain         types.String                 `tfsdk:"domain"`
	EnvironmentID  types.String                 `tfsdk:"environment_id"`
	Groups         []types.String               `tfsdk:"groups"`
	Hrid           types.String                 `tfsdk:"hrid"`
	ID             types.String                 `tfsdk:"id"`
	Members        []tfTypes.Member             `tfsdk:"members"`
	Metadata       []tfTypes.Metadata           `tfsdk:"metadata"`
	Name           types.String                 `tfsdk:"name"`
	NotifyMembers  types.Bool                   `tfsdk:"notify_members"`
	OrganizationID types.String                 `tfsdk:"organization_id"`
	PictureURL     types.String                 `tfsdk:"picture_url"`
	PrimaryOwner   *tfTypes.PrimaryOwner        `tfsdk:"primary_owner"`
	Settings       *tfTypes.ApplicationSettings `tfsdk:"settings"`
}

// Metadata returns the data source type name.
func (r *ApplicationDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_application"
}

// Schema defines the schema for the data source.
func (r *ApplicationDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Application DataSource",

		Attributes: map[string]schema.Attribute{
			"background": schema.StringAttribute{
				Computed:    true,
				Description: `Application's background url`,
			},
			"description": schema.StringAttribute{
				Computed:    true,
				Description: `This is where you can clearly state the API’s purpose and what problems it solves to help drive API discovery and adoption by making it easier for developers to find and understand the API’s capabilities.`,
			},
			"domain": schema.StringAttribute{
				Computed:    true,
				Description: `Application's domain.`,
			},
			"environment_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The environment ID of the Application.`,
			},
			"groups": schema.ListAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: `List of groups associated with the Application. This groups are names or UUIDs of existing groups in APIM.`,
			},
			"hrid": schema.StringAttribute{
				Required:    true,
				Description: `A unique human readable id identifying this resource`,
				Validators: []validator.String{
					stringvalidator.UTF8LengthAtMost(256),
					stringvalidator.RegexMatches(regexp.MustCompile(`^[a-zA-Z][a-zA-Z0-9_-]{2,}$`), "must match pattern "+regexp.MustCompile(`^[a-zA-Z][a-zA-Z0-9_-]{2,}$`).String()),
				},
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: `Application's uuid.`,
			},
			"members": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"role": schema.StringAttribute{
							Computed:    true,
							Description: `The role of the user in regards of the managed oject (API, Application, etc.)`,
						},
						"source": schema.StringAttribute{
							Computed:    true,
							Description: `Where the memeber was created (system, idp, etc.)`,
						},
						"source_id": schema.StringAttribute{
							Computed:    true,
							Description: `Id of the user in the source`,
						},
					},
				},
				Description: `Users that can access or manage this application (depending on their roles).`,
			},
			"metadata": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"default_value": schema.StringAttribute{
							Computed:    true,
							Description: `The default value of the metadata if the value is not set.`,
						},
						"format": schema.StringAttribute{
							Computed:    true,
							Description: `The format of the metadata.`,
						},
						"hidden": schema.BoolAttribute{
							Computed:    true,
							Description: `if this metadata should be hidden`,
						},
						"key": schema.StringAttribute{
							Computed:    true,
							Description: `The key of the metadata if different from sanitized name (lowercase + hyphens).`,
						},
						"name": schema.StringAttribute{
							Computed:    true,
							Description: `The name of the metadata.`,
						},
						"value": schema.StringAttribute{
							Computed:    true,
							Description: `The value of the metadata.`,
						},
					},
				},
				Description: `The list of Application's metadata.`,
			},
			"name": schema.StringAttribute{
				Computed:    true,
				Description: `Application's name. Duplicate names can exists.`,
			},
			"notify_members": schema.BoolAttribute{
				Computed: true,
				MarkdownDescription: `If true, new members added to the Application spec will` + "\n" +
					`be notified when the Application is synced with APIM.`,
			},
			"organization_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The organization ID of the Application.`,
			},
			"picture_url": schema.StringAttribute{
				Computed:    true,
				Description: `Application's picture Url.`,
			},
			"primary_owner": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"display_name": schema.StringAttribute{
						Computed:    true,
						Description: `Owner's name.`,
					},
					"email": schema.StringAttribute{
						Computed:    true,
						Description: `Owner's email. Can be null if owner is a group.`,
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Description: `Owner's uuid.`,
					},
					"type": schema.StringAttribute{
						Computed:    true,
						Description: `The type of membership`,
					},
				},
				Description: `User owner of this. Can perform all possible actions on it.`,
			},
			"settings": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"app": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"client_id": schema.StringAttribute{
								Computed:    true,
								Description: `Simple application client ID`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `Simple application type, for information`,
							},
						},
						Description: `Simple application settings`,
					},
					"oauth": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"additional_client_metadata": schema.MapAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"application_type": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `OAuth client application type: ` + "\n" +
									`` + "`" + `browser` + "`" + ` for single page apps (SPA),` + "\n" +
									`` + "`" + `web` + "`" + ` for regular web apps,` + "\n" +
									`` + "`" + `native` + "`" + ` for smartphone apps,` + "\n" +
									`` + "`" + `backend_to_backend` + "`" + ` for backend to backend.`,
							},
							"grant_types": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								MarkdownDescription: `OAuth client grant types. ` + "`" + `authorization_code` + "`" + ` is mandatory except when application type is ` + "`" + `backend_to_backend` + "`" + `.` + "\n" +
									`` + "`" + `refresh_token` + "`" + ` can be used only application type is ` + "`" + `web` + "`" + ` and ` + "`" + `browser` + "`" + `.` + "\n" +
									`` + "`" + `password` + "`" + ` (Resource Owner Password) only with applicationType ` + "`" + `native` + "`" + `.` + "\n" +
									`` + "`" + `client_credentials` + "`" + ` only works  when application type is ` + "`" + `backend_to_backend` + "`" + ``,
							},
							"redirect_uris": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `OAuth client redirect Uris`,
							},
						},
						Description: `Application OAuth client settings. This require Dynamic Client Registration to be enabled at the environment level.`,
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"client_certificate": schema.StringAttribute{
								CustomType:  customtypes.TrimmedStringType{},
								Computed:    true,
								Description: `Application TLS client certificate`,
							},
						},
						Description: `Application TLS settings`,
					},
				},
				Description: `Application settings defines the configuration of consumers authentication. Depending on the control plane configuration some applications types may be restricted. ` + "`" + `app` + "`" + ` and ` + "`" + `oauth` + "`" + ` are mutually exclusive. If none is set it fallbacks to ` + "`" + `app` + "`" + ` without any property set.`,
			},
		},
	}
}

func (r *ApplicationDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData, ok := req.ProviderData.(*ApimProviderConfigureData)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected *ApimProviderConfigureData, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.EnvironmentID = providerData.EnvironmentID
	r.OrganizationID = providerData.OrganizationID
	r.client = providerData.SDKClient
}

func (r *ApplicationDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data *ApplicationDataSourceModel
	var item types.Object

	resp.Diagnostics.Append(req.Config.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	if (data.EnvironmentID.IsNull() || data.EnvironmentID.IsUnknown()) && !r.EnvironmentID.IsUnknown() {
		data.EnvironmentID = r.EnvironmentID
	}

	if (data.OrganizationID.IsNull() || data.OrganizationID.IsUnknown()) && !r.OrganizationID.IsUnknown() {
		data.OrganizationID = r.OrganizationID
	}

	request, requestDiags := data.ToOperationsGetApplicationRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Applications.Get(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.ApplicationState != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedApplicationState(ctx, res.ApplicationState)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
