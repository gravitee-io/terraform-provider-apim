// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	speakeasy_boolplanmodifier "github.com/gravitee-io/terraform-provider-apim/internal/planmodifiers/boolplanmodifier"
	speakeasy_listplanmodifier "github.com/gravitee-io/terraform-provider-apim/internal/planmodifiers/listplanmodifier"
	speakeasy_objectplanmodifier "github.com/gravitee-io/terraform-provider-apim/internal/planmodifiers/objectplanmodifier"
	speakeasy_stringplanmodifier "github.com/gravitee-io/terraform-provider-apim/internal/planmodifiers/stringplanmodifier"
	"github.com/gravitee-io/terraform-provider-apim/internal/provider/customtypes"
	tfTypes "github.com/gravitee-io/terraform-provider-apim/internal/provider/types"
	"github.com/gravitee-io/terraform-provider-apim/internal/sdk"
	speakeasy_listvalidators "github.com/gravitee-io/terraform-provider-apim/internal/validators/listvalidators"
	speakeasy_objectvalidators "github.com/gravitee-io/terraform-provider-apim/internal/validators/objectvalidators"
	speakeasy_stringvalidators "github.com/gravitee-io/terraform-provider-apim/internal/validators/stringvalidators"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"regexp"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &ApplicationResource{}
var _ resource.ResourceWithImportState = &ApplicationResource{}

func NewApplicationResource() resource.Resource {
	return &ApplicationResource{}
}

// ApplicationResource defines the resource implementation.
type ApplicationResource struct {
	// Provider configured SDK client.
	client *sdk.GraviteeApim

	// environment ID
	EnvironmentID types.String `tfsdk:"environment_id"`

	// organization ID
	OrganizationID types.String `tfsdk:"organization_id"`
}

// ApplicationResourceModel describes the resource data model.
type ApplicationResourceModel struct {
	Background     types.String                 `tfsdk:"background"`
	Description    types.String                 `tfsdk:"description"`
	Domain         types.String                 `tfsdk:"domain"`
	EnvironmentID  types.String                 `tfsdk:"environment_id"`
	Groups         []types.String               `tfsdk:"groups"`
	Hrid           types.String                 `tfsdk:"hrid"`
	ID             types.String                 `tfsdk:"id"`
	Members        []tfTypes.Member             `tfsdk:"members"`
	Metadata       []tfTypes.Metadata           `tfsdk:"metadata"`
	Name           types.String                 `tfsdk:"name"`
	NotifyMembers  types.Bool                   `tfsdk:"notify_members"`
	OrganizationID types.String                 `tfsdk:"organization_id"`
	PictureURL     types.String                 `tfsdk:"picture_url"`
	PrimaryOwner   *tfTypes.PrimaryOwner        `tfsdk:"primary_owner"`
	Settings       *tfTypes.ApplicationSettings `tfsdk:"settings"`
	Status         types.String                 `tfsdk:"status"`
}

func (r *ApplicationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_application"
}

func (r *ApplicationResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Application Resource",
		Attributes: map[string]schema.Attribute{
			"background": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Application's background url`,
			},
			"description": schema.StringAttribute{
				Required:    true,
				Description: `This is where you can clearly state the API’s purpose and what problems it solves to help drive API discovery and adoption by making it easier for developers to find and understand the API’s capabilities.`,
				Validators: []validator.String{
					stringvalidator.UTF8LengthBetween(1, 4000),
				},
			},
			"domain": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Application's domain.`,
				Validators: []validator.String{
					stringvalidator.UTF8LengthAtMost(256),
				},
			},
			"environment_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `environment ID`,
			},
			"groups": schema.ListAttribute{
				Computed: true,
				Optional: true,
				Default:  listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
				PlanModifiers: []planmodifier.List{
					speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
				},
				ElementType: types.StringType,
				Description: `List of groups associated with the Application. This groups are names or UUIDs of existing groups in APIM. Default: []`,
			},
			"hrid": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `A unique human readable id identifying this resource. Requires replacement if changed.`,
				Validators: []validator.String{
					stringvalidator.UTF8LengthAtMost(256),
					stringvalidator.RegexMatches(regexp.MustCompile(`^[a-zA-Z][a-zA-Z0-9_-]{2,}$`), "must match pattern "+regexp.MustCompile(`^[a-zA-Z][a-zA-Z0-9_-]{2,}$`).String()),
				},
			},
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Application's uuid.`,
			},
			"members": schema.ListNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.List{
					speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
				},
				NestedObject: schema.NestedAttributeObject{
					Validators: []validator.Object{
						speakeasy_objectvalidators.NotNull(),
					},
					PlanModifiers: []planmodifier.Object{
						speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
					},
					Attributes: map[string]schema.Attribute{
						"role": schema.StringAttribute{
							Computed: true,
							Optional: true,
							PlanModifiers: []planmodifier.String{
								speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
							},
							Description: `The role of the user in regards of the managed oject (API, Application, etc.). Not Null`,
							Validators: []validator.String{
								speakeasy_stringvalidators.NotNull(),
							},
						},
						"source": schema.StringAttribute{
							Computed: true,
							Optional: true,
							PlanModifiers: []planmodifier.String{
								speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
							},
							Description: `Where the memeber was created (system, idp, etc.). Not Null`,
							Validators: []validator.String{
								speakeasy_stringvalidators.NotNull(),
							},
						},
						"source_id": schema.StringAttribute{
							Computed: true,
							Optional: true,
							PlanModifiers: []planmodifier.String{
								speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
							},
							Description: `Id of the user in the source. Not Null`,
							Validators: []validator.String{
								speakeasy_stringvalidators.NotNull(),
							},
						},
					},
				},
				Description: `Users that can access or manage this application (depending on their roles).`,
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"metadata": schema.ListNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.List{
					speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
				},
				NestedObject: schema.NestedAttributeObject{
					Validators: []validator.Object{
						speakeasy_objectvalidators.NotNull(),
					},
					PlanModifiers: []planmodifier.Object{
						speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
					},
					Attributes: map[string]schema.Attribute{
						"default_value": schema.StringAttribute{
							Computed: true,
							Optional: true,
							PlanModifiers: []planmodifier.String{
								speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
							},
							Description: `The default value of the metadata if the value is not set.`,
						},
						"format": schema.StringAttribute{
							Computed: true,
							Optional: true,
							PlanModifiers: []planmodifier.String{
								speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
							},
							Description: `The format of the metadata. Not Null; must be one of ["STRING", "NUMERIC", "BOOLEAN", "DATE", "MAIL", "URL"]`,
							Validators: []validator.String{
								speakeasy_stringvalidators.NotNull(),
								stringvalidator.OneOf(
									"STRING",
									"NUMERIC",
									"BOOLEAN",
									"DATE",
									"MAIL",
									"URL",
								),
							},
						},
						"hidden": schema.BoolAttribute{
							Computed: true,
							Optional: true,
							Default:  booldefault.StaticBool(false),
							PlanModifiers: []planmodifier.Bool{
								speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
							},
							Description: `if this metadata should be hidden. Default: false`,
						},
						"key": schema.StringAttribute{
							Computed: true,
							Optional: true,
							PlanModifiers: []planmodifier.String{
								speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
							},
							Description: `The key of the metadata if different from sanitized name (lowercase + hyphens).`,
							Validators: []validator.String{
								stringvalidator.UTF8LengthAtLeast(1),
							},
						},
						"name": schema.StringAttribute{
							Computed: true,
							Optional: true,
							PlanModifiers: []planmodifier.String{
								speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
							},
							Description: `The name of the metadata. Not Null`,
							Validators: []validator.String{
								speakeasy_stringvalidators.NotNull(),
							},
						},
						"value": schema.StringAttribute{
							Computed: true,
							Optional: true,
							PlanModifiers: []planmodifier.String{
								speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
							},
							Description: `The value of the metadata.`,
							Validators: []validator.String{
								stringvalidator.UTF8LengthAtLeast(1),
							},
						},
					},
				},
				Description: `The list of Application's metadata.`,
			},
			"name": schema.StringAttribute{
				Required:    true,
				Description: `Application's name. Duplicate names can exists.`,
				Validators: []validator.String{
					stringvalidator.UTF8LengthBetween(1, 512),
				},
			},
			"notify_members": schema.BoolAttribute{
				Computed: true,
				Optional: true,
				Default:  booldefault.StaticBool(false),
				MarkdownDescription: `If true, new members added to the Application spec will` + "\n" +
					`be notified when the Application is synced with APIM.` + "\n" +
					`Default: false`,
			},
			"organization_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `organization ID`,
			},
			"picture_url": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Application's picture Url.`,
			},
			"primary_owner": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"display_name": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Owner's name.`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(1),
						},
					},
					"email": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Owner's email. Can be null if owner is a group.`,
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Owner's uuid.`,
					},
					"type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `The type of membership. must be one of ["USER", "GROUP"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"USER",
								"GROUP",
							),
						},
					},
				},
				Description: `User owner of this. Can perform all possible actions on it.`,
			},
			"settings": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"app": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"client_id": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Simple application client ID`,
								Validators: []validator.String{
									stringvalidator.UTF8LengthAtMost(300),
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Simple application type, for information`,
							},
						},
						Description: `Simple application settings`,
					},
					"oauth": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"additional_client_metadata": schema.MapAttribute{
								Computed:    true,
								Optional:    true,
								ElementType: types.StringType,
							},
							"application_type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								MarkdownDescription: `OAuth client application type: ` + "\n" +
									`` + "`" + `browser` + "`" + ` for single page apps (SPA),` + "\n" +
									`` + "`" + `web` + "`" + ` for regular web apps,` + "\n" +
									`` + "`" + `native` + "`" + ` for smartphone apps,` + "\n" +
									`` + "`" + `backend_to_backend` + "`" + ` for backend to backend.` + "\n" +
									`Not Null; must be one of ["browser", "web", "native", "backend_to_backend"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"browser",
										"web",
										"native",
										"backend_to_backend",
									),
								},
							},
							"grant_types": schema.ListAttribute{
								Computed:    true,
								Optional:    true,
								ElementType: types.StringType,
								MarkdownDescription: `OAuth client grant types. ` + "`" + `authorization_code` + "`" + ` is mandatory except when application type is ` + "`" + `backend_to_backend` + "`" + `.` + "\n" +
									`` + "`" + `refresh_token` + "`" + ` can be used only application type is ` + "`" + `web` + "`" + ` and ` + "`" + `browser` + "`" + `.` + "\n" +
									`` + "`" + `password` + "`" + ` (Resource Owner Password) only with applicationType ` + "`" + `native` + "`" + `.` + "\n" +
									`` + "`" + `client_credentials` + "`" + ` only works  when application type is ` + "`" + `backend_to_backend` + "`" + `` + "\n" +
									`Not Null`,
								Validators: []validator.List{
									speakeasy_listvalidators.NotNull(),
									listvalidator.SizeAtLeast(1),
									listvalidator.UniqueValues(),
								},
							},
							"redirect_uris": schema.ListAttribute{
								Computed:    true,
								Optional:    true,
								Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								ElementType: types.StringType,
								Description: `OAuth client redirect Uris. Default: []`,
							},
						},
						Description: `Application OAuth client settings. This require Dynamic Client Registration to be enabled at the environment level.`,
					},
					"tls": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"client_certificate": schema.StringAttribute{
								CustomType:  customtypes.TrimmedStringType{},
								Computed:    true,
								Optional:    true,
								Description: `Application TLS client certificate. Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
						},
						Description: `Application TLS settings`,
					},
				},
				Description: `Application settings defines the configuration of consumers authentication. Depending on the control plane configuration some applications types may be restricted. ` + "`" + `app` + "`" + ` and ` + "`" + `oauth` + "`" + ` are mutually exclusive. If none is set it fallbacks to ` + "`" + `app` + "`" + ` without any property set.`,
			},
			"status": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Default:     stringdefault.StaticString(`ACTIVE`),
				Description: `Application are either ACTIVE or ARCHIVED never actually deleted. Default: "ACTIVE"; must be one of ["ACTIVE", "ARCHIVED"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"ACTIVE",
						"ARCHIVED",
					),
				},
			},
		},
	}
}

func (r *ApplicationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData, ok := req.ProviderData.(*ApimProviderConfigureData)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *ApimProviderConfigureData, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.EnvironmentID = providerData.EnvironmentID
	r.OrganizationID = providerData.OrganizationID
	r.client = providerData.SDKClient
}

func (r *ApplicationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *ApplicationResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	if (data.EnvironmentID.IsNull() || data.EnvironmentID.IsUnknown()) && !r.EnvironmentID.IsUnknown() {
		data.EnvironmentID = r.EnvironmentID
	}

	if (data.OrganizationID.IsNull() || data.OrganizationID.IsUnknown()) && !r.OrganizationID.IsUnknown() {
		data.OrganizationID = r.OrganizationID
	}

	request, requestDiags := data.ToOperationsCreateOrUpdateApplicationsRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Applications.CreateOrUpdate(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.ApplicationState != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedApplicationState(ctx, res.ApplicationState)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsGetApplicationRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.Applications.Get(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.ApplicationState != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedApplicationState(ctx, res1.ApplicationState)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ApplicationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *ApplicationResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsGetApplicationRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Applications.Get(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.ApplicationState != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedApplicationState(ctx, res.ApplicationState)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ApplicationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *ApplicationResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	if (data.EnvironmentID.IsNull() || data.EnvironmentID.IsUnknown()) && !r.EnvironmentID.IsUnknown() {
		data.EnvironmentID = r.EnvironmentID
	}

	if (data.OrganizationID.IsNull() || data.OrganizationID.IsUnknown()) && !r.OrganizationID.IsUnknown() {
		data.OrganizationID = r.OrganizationID
	}

	request, requestDiags := data.ToOperationsCreateOrUpdateApplicationsRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Applications.CreateOrUpdate(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.ApplicationState != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedApplicationState(ctx, res.ApplicationState)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsGetApplicationRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.Applications.Get(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.ApplicationState != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedApplicationState(ctx, res1.ApplicationState)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ApplicationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *ApplicationResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	if (data.EnvironmentID.IsNull() || data.EnvironmentID.IsUnknown()) && !r.EnvironmentID.IsUnknown() {
		data.EnvironmentID = r.EnvironmentID
	}

	if (data.OrganizationID.IsNull() || data.OrganizationID.IsUnknown()) && !r.OrganizationID.IsUnknown() {
		data.OrganizationID = r.OrganizationID
	}

	request, requestDiags := data.ToOperationsDeleteApplicationRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Applications.Delete(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 204 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *ApplicationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	dec := json.NewDecoder(bytes.NewReader([]byte(req.ID)))
	dec.DisallowUnknownFields()
	var data struct {
		EnvironmentID  *string `json:"environment_id"`
		Hrid           string  `json:"hrid"`
		OrganizationID *string `json:"organization_id"`
	}

	if err := dec.Decode(&data); err != nil {
		resp.Diagnostics.AddError("Invalid ID", `The import ID is not valid. It is expected to be a JSON object string with the format: '{"environment_id": "a44e0d1b-9fa9-4d64-8b76-3634623a2e27", "hrid": "my_demo_api", "organization_id": "dedd0e0f-b3e9-4d2f-89cd-b2a9de7cb145"}': `+err.Error())
		return
	}

	if data.EnvironmentID == nil {
		if !r.EnvironmentID.IsUnknown() {
			data.EnvironmentID = r.EnvironmentID.ValueStringPointer()
		}
		if data.EnvironmentID == nil {
			resp.Diagnostics.AddError("Missing required field", `The field environment_id is required but was not found in the json encoded ID. It's expected to be a value alike '"a44e0d1b-9fa9-4d64-8b76-3634623a2e27"`)
			return
		}
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("environment_id"), data.EnvironmentID)...)
	if len(data.Hrid) == 0 {
		resp.Diagnostics.AddError("Missing required field", `The field hrid is required but was not found in the json encoded ID. It's expected to be a value alike '"my_demo_api"`)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("hrid"), data.Hrid)...)
	if data.OrganizationID == nil {
		if !r.OrganizationID.IsUnknown() {
			data.OrganizationID = r.OrganizationID.ValueStringPointer()
		}
		if data.OrganizationID == nil {
			resp.Diagnostics.AddError("Missing required field", `The field organization_id is required but was not found in the json encoded ID. It's expected to be a value alike '"dedd0e0f-b3e9-4d2f-89cd-b2a9de7cb145"`)
			return
		}
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("organization_id"), data.OrganizationID)...)
}
